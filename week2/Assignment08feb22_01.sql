https://www.oracletutorial.com/oracle-index/oracle-create-index/
https://www.oracletutorial.com/oracle-index/oracle-unique-index/
https://www.oracletutorial.com/oracle-index/oracle-function-based-index/
https://www.oracletutorial.com/oracle-index/oracle-bitmap-index/
https://www.oracletutorial.com/oracle-string-functions/
https://www.oracletutorial.com/oracle-basics/oracle-fetch/

--$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
--CREATING INDEX
/*CREATE INDEX index_name 
ON table_name(column1[,column2,...])*/

--$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

CREATE TABLE members(
    member_id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(100) NOT NULL,
    last_name VARCHAR2(100) NOT NULL,
    gender CHAR(1) NOT NULL,
    dob DATE NOT NULL,
    email VARCHAR2(255) NOT NULL,
    PRIMARY KEY(member_id)
);

SELECT * FROM members;

SELECT 
    index_name, index_type,visibility 
FROM 
    all_indexes
WHERE 
    TABLE_NAME = 'MEMBERS';

--Creating an index on one column example

CREATE INDEX members_last_name_i 
ON members(last_name);

--

SELECT * FROM members
WHERE last_name = 'Harse';


EXPLAIN PLAN FOR
SELECT * FROM members
WHERE last_name = 'Harse';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
/*
Plan hash value: 3383195609
 
-----------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name                | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                     |     1 |    52 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| MEMBERS             |     1 |    52 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | MEMBERS_LAST_NAME_I |     1 |       |     1   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("LAST_NAME"='Harse') */

--Removing an index
DROP INDEX members_last_name_i;

DROP INDEX I_MEMBERS_NAME ;

CREATE INDEX members_name_i 
ON members(last_name,first_name);

SELECT 
    *
FROM 
    all_indexes
WHERE 
    TABLE_NAME = 'MEMBERS';
    
--------

SELECT 
     first_name, last_name
FROM 
    members
WHERE 
    last_name LIKE 'A%' 
    AND 
    first_name LIKE 'M%';


EXPLAIN PLAN FOR
SELECT 
    first_name,last_name 
FROM 
    members
WHERE 
    last_name LIKE 'A%' 
    AND 
    first_name LIKE 'M%';
    
    
SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
    
/*    
Plan hash value: 88980219
 
-----------------------------------------------------------------------------------
| Id  | Operation        | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                |     1 |    16 |     2   (0)| 00:00:01 |
|*  1 |  INDEX RANGE SCAN| MEMBERS_NAME_I |     1 |    16 |     2   (0)| 00:00:01 |
-----------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("LAST_NAME" LIKE 'A%' AND "FIRST_NAME" LIKE 'M%')
       filter("LAST_NAME" LIKE 'A%' AND "FIRST_NAME" LIKE 'M%') */ 
       
       
----$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
--Introduction to Oracle UNIQUE index
    --use Oracle unique index to prevent duplicate values in the indexed column or columns of a table.
    --A unique index ensures that no two rows of a table have duplicate values in the indexed column
    -- 
----$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

-- Oracle UNIQUE index on one column example
select * from members;

CREATE UNIQUE INDEX member_email_i
ON 
members(email);

-- now will try to enter the same email which already exist in table ;

INSERT INTO members(first_name, last_name, gender, dob, email) VALUES ('jimil','parmar','M',DATE  '1999-09-22', 'pelce0@trellian.com');


/*Error starting at line : 145 in command -
INSERT INTO members(first_name, last_name, gender, dob, email) VALUES ('jimil','parmar','M',DATE  '1999-09-22', 'pelce0@trellian.com')
Error report -
ORA-00001: unique constraint (C##ADUSER.SYS_C008385) violated*/


-------Oracle UNIQUE index on two columns example

CREATE TABLE unq_idx_demo(
    a INT,
    b INT
);   

CREATE UNIQUE INDEX unq_idx_demo_ab_i
ON unq_idx_demo(a,b);

INSERT INTO unq_idx_demo(a,b)
VALUES(1,1);

--because we have a unique index on the a and b columns, the combination of values in both columns are used for evaluating duplicate.

INSERT INTO unq_idx_demo(a,b)
VALUES(1,2);

--  This will be inserted as this combination is not exist in the table 

INSERT INTO unq_idx_demo(a,b)
VALUES(1,1);

/*
Error starting at line : 174 in command -
INSERT INTO unq_idx_demo(a,b)
VALUES(1,1)
Error report -
ORA-00001: unique constraint (C##ADUSER.UNQ_IDX_DEMO_AB_I) violated*/



-------Oracle UNIQUE index, Primary Key constraint, and Unique constraint

--When you define a PRIMARY KEY or a UNIQUE constraint for a table, Oracle automatically 
--creates a unique index on the primary key or unique key columns to enforce the uniqueness.


CREATE TABLE t1 (
    pk1 INT PRIMARY KEY,
    c1 INT
);

SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'T1';

-- To specify the name for the primary key column, you use the UNIQUE index as shown in the following query:
CREATE TABLE t2 (
    pk2 INT PRIMARY KEY 
        USING INDEX (
            CREATE INDEX t1_pk1_i ON t2 (pk2)
    ),
    c2 INT
);

SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'T2';



---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--Oracle Function-based Index
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Function-based index to speed up queries that consist of functions.
-- A function-based index calculates the result of a function that involves 
        --one or more columns and stores that result in the index.
/*

CREATE INDEX index_name
ON table_name (expression)

The index expression can be an arithmetic expression or an expression that contains a function such as a SQL function, 
PL/SQL function, and package function.


Note that a function-based index can be a btree or bitmap inde



*/
---!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

CREATE INDEX 
    members_last_name_fi
ON 
    members(UPPER(last_name));
    
-- Oracle converted all values in the last_name column to uppercase and stored these results in 
--the members_last_name_fi index.

EXPLAIN PLAN FOR
SELECT 
    * 
FROM    
    members
WHERE 
    UPPER(last_name) = 'SANS';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());

/*
Plan hash value: 3212696895
 
------------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name                 | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                      |    10 |   520 |     4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| MEMBERS              |    10 |   520 |     4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | MEMBERS_LAST_NAME_FI |     4 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access(UPPER("LAST_NAME")='SANS')*/






--*************************************************************************************************************************
--*************************************************************************************************************************
-- Oracle Bitmap Index
--*************************************************************************************************************************
--bitmap index for indexing columns with low cardinality.
--
--*************************************************************************************************************************


--  Oracle bitmap index 
SELECT 
    *
FROM 
    members
WHERE 
    gender = 'M';

-- Gender column has two distinct values M,F, when a column has a few distinct values, we say that this column has low cardinality  
/*
For example, if you create a bitmap index on the gender column of the members table. The structure of the bitmap index looks like the following picture:

It has two separate bitmaps, one for each gender.

Oracle uses a mapping function to converts each bit in the bitmap to the corresponding rowid of the members table
*/

CREATE BITMAP INDEX 
    member_gender_i
ON
    members(gender);

---------------------------
EXPLAIN PLAN FOR 
SELECT 
    *
FROM
    members
WHERE
    gender = 'F';

    
SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());      
/*
Plan hash value: 3682585452
 
-----------------------------------------------------------------------------
| Id  | Operation         | Name    | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |         |   499 | 25948 |     5   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| MEMBERS |   499 | 25948 |     5   (0)| 00:00:01 |
-----------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("GENDER"='F')
*/

---When to use Oracle bitmap indexes

-- Low cardinality columns
SELECT 
    gender, COUNT(*)
FROM 
    members
GROUP BY 
    gender;


-- Infrequently updated or read-only tables

CREATE TABLE bitmap_index_demo(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    active NUMBER NOT NULL,
    PRIMARY KEY(id)
);

CREATE BITMAP INDEX 
    bitmap_index_demo_active_i
ON 
    bitmap_index_demo(active);

   
INSERT INTO bitmap_index_demo(active) 
VALUES(1);

INSERT INTO bitmap_index_demo(active) 
VALUES(0);



--========================================================================================================================
--========================================================================================================================
 
 String functions 
--========================================================================================================================
--========================================================================================================================

SELECT 
    ASCII('J') 
FROM 
    DUAL;
    
-----------------

SELECT 
    CHR('74')
FROM 
    DUAL;
    
------------------

SELECT 
        CONCAT('JIM','IL')
FROM DUAL;

--------------------
SELECT  
    DUMP('J')    
FROM 
    DUAL;
    
--------------------
SELECT  
    INITCAP('jimil parmar')
FROM 
    DUAL;
--------------------
SELECT  
    INSTR('This is jimil here','jimil')    
FROM 
    DUAL;
--------------------
SELECT  
    LENGTH('JIMIL')    
FROM 
    DUAL;
--------------------
SELECT  
    LOWER('JIMIL')    
FROM 
    DUAL;
--------------------
SELECT  
    UPPER('jimil')    
FROM 
    DUAL;
--------------------
SELECT  
    LPAD('JIMIL',10,'$')    
FROM 
    DUAL;
--------------------
SELECT  
    LTRIM('JIMIL         ')    
FROM 
    DUAL;
--------------------
SELECT  
    LENGTH('JIMIL')    
FROM 
    DUAL;
    
    
    
--========================================================================================================================
--========================================================================================================================
 Oracle FETCH
--========================================================================================================================
 -- FETCH clause to limit the rows returned by a query.
 
 
 [ OFFSET offset ROWS]
 FETCH  NEXT [  row_count | percent PERCENT  ] ROWS  [ ONLY | WITH TIES ] 

 The OFFSET clause specifies the number of rows to skip before the row limiting starts. 
 => If the offset is negative, then it is treated as 0.
 =>If the offset is NULL or greater than the number of rows returned by the query, then no row is returned
 =>If the offset includes a fraction, then the fractional portion is truncated.
--========================================================================================================================

SELECT
    *
FROM 
    members
FETCH NEXT 5 ROWS ONLY;

